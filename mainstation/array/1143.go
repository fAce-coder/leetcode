package array

func longestCommonSubsequence(text1 string, text2 string) int {
	// 动态规划

	/*
		本题要求长度为m的字符串text1和长度为n的字符串text2的最长公共子序列，且这个子序列可以是不连续的；因此考虑将这一大问题，拆分为text1长度某个长度的前缀字符串，与text2某个长度的前缀字符串，所能达到的最大公共子序列长度这一子问题；因此考虑使用动态规划
		1.状态（子问题）：
			子问题为text1长度为i的前缀字符串，与text2长度为j的前缀字符串，所能得到的最大公共子序列
			为保证子问题每次扩张都是最小化的，因此每次只能i或j其中的一个增长1，即i和j不能同时增长，因此状态数组是2维的，每一维分别记录i或j的长度
			状态数组dp[i][j]：text1长度为i的前缀字符串，与text2长度为j的前缀字符串，所能得到的最大公共子序列
		2.起始状态：
			当i=0时，text1为空，空字符串与任何字符串所达到的最长公共子序列的长度都是0，因此对于任意j，dp[0][j]=0，即状态数组第一行为0
			当j=0时，text2为空，空字符串与任何字符串所达到的最长公共子序列的长度都是0，因此对于任意i，dp[i][0]=0，即状态数组第一列为0
		3.状态转移：
			3.1 当前缀长度为i的text1的最后一个字符与前缀长度为j的text2的最后一个字符相同，即text1[i-1]=text2[j-1]：
				说明前缀长度为i的text1和前缀长度为j的text2，相比前缀长度为i-1的text1和前缀长度为j-1的text2，所能达到的最大公共子序列长度又可以多加上这一公共字符，即：dp[i][j]=dp[i-1][j-1]+1
			3.2 当前缀长度为i的text1的最后一个字符与前缀长度为j的text2的最后一个字符不相同，即text1[i-1]!=text2[j-1]：
				因不是公共字符，所以说明前缀长度为i的text1和前缀长度为j的text2，无法在前缀长度为i-1的text1和前缀长度为j-1的text2的基础上将最大公共子序列长度加1
				因此将离当前子问题最近的2个子问题的较大值，作为当前子问题的值
				离当前子问题最近的2个子问题（子问题扩张最小化，只移动i或j中的一位）：前缀长度为i的text1和前缀长度为j-1的text2；前缀长度为i-1的text1和前缀长度为j的text2
				即：dp[i][j]=max(dp[i-1][j],dp[i][j-1])
		最终text1前缀长度为m，text2前缀长度为n，即完整的text1和text2，此时所能得到的最长公共子序列即dp[m-1][n-1]，就是我们要求的最终结果
	*/

	// 1.状态：
	// 状态数组dp[i][j]：text1长度为i的前缀字符串，与text2长度为j的前缀字符串，所能得到的最大公共子序列
	m := len(text1) + 1
	n := len(text2) + 1
	dp := make([][]int, m)
	for k := 0; k < m; k++ {
		dp[k] = make([]int, n)
	}

	// 2.起始状态：
	// 当i=0时，text1为空，空字符串与任何字符串所达到的最长公共子序列的长度都是0，因此对于任意j，dp[0][j]=0，即状态数组第一行为0
	// 当j=0时，text2为空，空字符串与任何字符串所达到的最长公共子序列的长度都是0，因此对于任意i，dp[i][0]=0，即状态数组第一列为0
	// 因go切片中默认值就是0，因此不做处理

	// 3.状态转移
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			if text1[i-1] == text2[j-1] {
				// 当前缀长度为i的text1的最后一个字符与前缀长度为j的text2的最后一个字符相同，即text1[i-1]=text2[j-1]
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				// 当前缀长度为i的text1的最后一个字符与前缀长度为j的text2的最后一个字符不相同，即text1[i-1]!=text2[j-1]
				dp[i][j] = maxInt(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	// 4.最终text1前缀长度为m，text2前缀长度为n，即完整的text1和text2，此时所能得到的最长公共子序列即dp[m-1][n-1]，就是我们要求的最终结果
	return dp[m-1][n-1]
}
