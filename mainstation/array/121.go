package array

func maxProfit(prices []int) int {
	// 动态规划

	/*
		本题要求整个周期中，买卖一次股票所能得到的最大利润；即从周期的第一天开始，到周期的最后一天为止，买卖一次股票所能得到的最大利润
		因此考虑将求整个周期中股票最大利润的这一大问题，拆分成以周期中的每一天为止所能达到的最大利润
		1.状态（子问题）：
			状态数组dp[i]表示以第i天为止所能得到的最大利润
		2.起始状态：
			如果以第0天为止，无论是当天没有发生股票买卖（没有买入），还是发生了股票买卖（买入后随即卖出了），利润都是0，因此dp[0]=0
		3.状态转移：
			因为整个周期只进行了一次股票买卖，则：
			3.1 如果第i天没有发生股票买卖
				则第i天为止的最大利润与第i-1天为止的最大利润相同，即dp[i]=dp[i-1]
			3.2 如果第i天发生了股票买卖
				因为第i天卖出了股票，则买入股票的时间一定要在第i天之前，且为了保证买卖得到的收益最大，所以要保证买入的价格是前i天最低的价格
				因此用一个标志位minPrice来维护前i天的股票最低价格，而第i天为止得到的最大收益，就是第i天的股票价格减去前i天最低的价格minPrice，即：dp[i]=prices[i]-minPrice
			3.3 因为第i天可能发生了股票买卖，也可能没发生股票买卖，因此以第i天为止的最大利润是两种情况的最大值
	*/

	// 1.状态数组dp[i]表示以第i天为止所能得到的最大利润
	n := len(prices)
	dp := make([]int, n)

	// 2.起始状态：
	dp[0] = 0             // 如果以第0天为止，无论是当天没有发生股票买卖（没有买入），还是发生了股票买卖（买入后随即卖出了），利润都是0，因此dp[0]=0
	minPrice := prices[0] // 标志位minPrice来维护前i天的股票最低价格

	// 3.状态转移
	for i := 1; i < n; i++ {
		// 如果第i天没有发生股票买卖，则第i天为止的最大利润与第i-1天为止的最大利润相同，即dp[i]=dp[i-1]
		// 如果第i天发生了股票买卖，因为第i天卖出了股票，则买入股票的时间一定要在第i天之前，且为了保证买卖得到的收益最大，所以要保证买入的价格是前i天最低的价格；用一个标志位minPrice来维护前i天的股票最低价格，而第i天为止得到的最大收益，就是第i天的股票价格减去前i天最低的价格minPrice，即：dp[i]=prices[i]-minPrice
		minPrice = minInt(minPrice, prices[i])
		dp[i] = maxInt(dp[i-1], prices[i]-minPrice)
	}

	// 4.到周期最后一天为止所能得到的最大收益，就是我们要求的结果
	return dp[n-1]
}
