package array

func maxProfit2(prices []int) int {
	// 动态规划

	/*
		本题要求整个周期中，买卖多次股票所能得到的最大利润；即从周期的第一天开始，到周期的最后一天为止，买卖多次股票所能得到的最大利润
		因此将求整个周期这一大问题，拆分成求：从周期第一天开始，到某一天为止，买卖多次股票所能得到的最大利润 这一子问题，因此考虑动态规划
		1.状态（子问题）：
			从周期第1天开始，到周期第i天为止所能得到的最大利润，而第i天可能有2种状态，要么持有股票，要么没持有股票
			状态数组dp0[i]表示第i天不持有股票所能得到的最大利润
			状态数组dp1[i]表示第i天持有股票时所能得到的最大利润
		2.起始状态：
			当第0天不持有股票，说明第0天没买入股票，则利润为0，即：dp0[0]=0
			当第0天持有股票，说明第0天买入了股票，则利润为0减买入股票的钱，即：dp1[0]=-prices[0]
		3.状态转移：
			当第i天不持有股票：
				如果是第i-1天还持有，在第i天当天卖出的，则此时第i天为止利润=第i-1天为止的利润减去第i天卖出股票的收益，即：dp0[i]=dp1[i-1]+prices[i]
				如果是第i-1天已经不持有了，在第i天也没买入，则此时第i天为止的利润=第i-1天为止的利润，即：dp0[i]=dp0[i-1]
				而第i天不持有股票所能得到的最大利润，是上述两种情况的较大值
			当第i天持有股票：
				如果是第i-1天不持有，在第i天当前买入的，则此时第i天为止的利润=第i-1天为止的利润加上第i天买入股票花的钱，即：dp1[i]=dp0[i-1]-prices[i]
				如果是第i-1天已经持有了，在第i天也没卖出，则此时第i天为止的利润=第i-1天为止的利润，即：dp1[i]=dp1[i-1]
				而第i天持有股票所能得到的最大利润，是上述两种情况的较大值
			因为要想利益最大，最后一天一定要将股票全部卖出，即最后一天一定不会持有股票，因此dp0[n-1]就是整个周期中买卖多次股票所能得到的最大利润
	*/

	// 1.初始化状态数组
	n := len(prices)
	dp0 := make([]int, n) // 状态数组dp0[i]表示第i天不持有股票所能得到的最大利润
	dp1 := make([]int, n) // 状态数组dp1[i]表示第i天持有股票时所能得到的最大利润

	// 2.起始状态
	dp0[0] = 0          // 当第0天不持有股票，说明第0天没买入股票，则利润为0，即：dp0[0]=0
	dp1[0] = -prices[0] // 当第0天持有股票，说明第0天买入了股票，则利润为0减买入股票的钱，即：dp1[0]=-prices[0]

	// 3.状态转移
	for i := 1; i < n; i++ {
		// 3.1 当第i天不持有股票：
		// 如果是第i-1天还持有，在第i天当天卖出的，则此时第i天为止利润=第i-1天为止的利润减去第i天卖出股票的收益，即：dp0[i]=dp1[i-1]+prices[i]
		// 如果是第i-1天已经不持有了，在第i天也没买入，则此时第i天为止的利润=第i-1天为止的利润，即：dp0[i]=dp0[i-1]
		// 而第i天不持有股票所能得到的最大利润，是上述两种情况的较大值
		dp0[i] = maxInt(dp1[i-1]+prices[i], dp0[i-1])
		// 3.2 当第i天持有股票：
		// 如果是第i-1天不持有，在第i天当前买入的，则此时第i天为止的利润=第i-1天为止的利润加上第i天买入股票花的钱，即：dp1[i]=dp0[i-1]-prices[i]
		// 如果是第i-1天已经持有了，在第i天也没卖出，则此时第i天为止的利润=第i-1天为止的利润，即：dp1[i]=dp1[i-1]
		// 而第i天持有股票所能得到的最大利润，是上述两种情况的较大值
		dp1[i] = maxInt(dp0[i-1]-prices[i], dp1[i-1])
	}

	// 4.要想利益最大，最后一天一定要将股票全部卖出，即最后一天一定不会持有股票，因此dp0[n-1]就是整个周期中买卖多次股票所能得到的最大利润
	return dp0[n-1]
}
