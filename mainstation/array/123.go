package array

func maxProfit5(prices []int) int {
	// 动态规划

	/*
		本题要求整个周期中最多买卖两次股票所能获得的最大利润，即从第0天开始，到最后一天为止，至多买卖2次股票所能得到的最大利润
		因此考虑将整个周期所能获得的最大利润，拆分成从第0天开始，到周期中的某一天为止，至多买卖2次股票所能得到的最大利润，因此考虑动态规划
		1.状态（子问题）：
			从第0天开始，到第i天为止，至多买卖2次股票所能获得的最大利润
			第i天可能有以下几种状态：
				状态数组dp00：第i天不持有股票，卖出过0次
				状态数组dp01：第i天不持有股票，卖出过1次
				状态数组dp02：第i天不持有股票，卖出过2次
				状态数组dp10：第i天持有股票，卖出过0次
				状态数组dp11：第i天持有股票，卖出过1次
				因为最多只能买卖2次，因此第i天持有股票的情况下，不可能已经卖出过2次，因此状态数组dp12不存在
		2.起始状态：
			第0天不持有股票，且卖出过0次，说明第0天没有发生任何交易，利润为0，即：dp00[0]=0
			第0天不持有股票，且卖出过1次，说明第0天买了1次又立马卖了，利润为0，即：dp01[0]=0
			第0天不持有股票，且卖出过2次，说明第0天买卖了2次，利润为0，即：dp02[0]=0
			第0天持有股票，且卖出过0次，说明第0天买入了股票，利润为负的买入股票花的钱，即dp10[0]=-prices[0]
			第0天持有股票，且卖出过1次，说明第0天买卖了一次股票，并又买入了一次，利润为负的买入股票花的钱，即dp11[0]=-prices[0]
		3.状态转移：
			第i天不持有股票：
				卖出过0次：此时由于没有发生过股票买卖，因此利润一直是0，即dp00[i]=0
				卖出过1次：
					可能是第i-1天持股且卖出过0次，是在第i天当天卖出的，此时第i天为止的利润=第i-1天为止的利润+第i天卖出股票赚的钱，即：dp01[i]=dp10[i-1]+prices[i]
					可能是第i-1天已经不持股且卖出过1次，第i天当天也没有买入，此时第i天为止的利润=第i-1天为止的利润，即：dp01[i]=dp01[i-1]
					第i天不持有股票且卖出过1次的最大利润，是上述两种情况的较大值
				卖出过2次：
					可能是第i-1天持股且卖出过1次，是在第i天当天卖出的，此时第i天为止的利润=第i-1天为止的利润+第i天卖出股票赚的钱，即：dp02[i]=dp11[i-1]+prices[i]
					可能是第i-1天已经不持股且卖出过2次，第i天当天也没有买入，此时第i天为止的利润=第i-1天为止的利润，即：dp02[i]=dp02[i-1]
					第i天不持有股票且卖出过2次的最大利润，是上述两种情况的较大值
			第i天持有股票：
				卖出过0次：
					可能是第i-1天未持有且卖出过0次，是在第i天当天买入的，此时第i天为止的利润=第i-1天为止的利润+第i天买入股票花的钱，即：dp10[i]=dp00[i-1]-prices[i]
					可能是第i-1天已经持有股票且卖出过0次，而第i天当天也没有卖出，此时第i天为止的利润=第i-1天为止的利润，即：dp10[i]=dp10[i-1]
					第i天持有股票且卖出过0次的最大利润，是上述两种情况的较大值
				卖出过1次：
					可能是第i-1天未持有且卖出过1次，是在第i天当天买入的，此时第i天为止的利润=第i-1天为止的利润+第i天买入股票花的钱，即：dp11[i]=dp01[i-1]-prices[i]
					可能是第i-1天已经持有股票且卖出过1次，而第i天当天也没有卖出，此时第i天为止的利润=第i-1天为止的利润，即：dp11[i]=dp11[i-1]
					第i天持有股票且卖出过1次的最大利润，是上述两种情况的较大值
			因为要想利益最大，最后一天一定要将股票全部卖出，即最后一天一定不会持有股票，因此dp00[n-1],dp01[n-1],dp02[n-1]的较大值，就是整个周期中买卖多次股票所能得到的最大利润
	*/

	// 1.状态：从第0天开始，到第i天为止，至多买卖2次股票所能获得的最大利润
	// 第i天可能有以下几种状态：
	n := len(prices)
	dp00 := make([]int, n) // 状态数组dp00：第i天不持有股票，卖出过0次
	dp01 := make([]int, n) // 状态数组dp01：第i天不持有股票，卖出过1次
	dp02 := make([]int, n) // 状态数组dp02：第i天不持有股票，卖出过2次
	dp10 := make([]int, n) // 状态数组dp10：第i天持有股票，卖出过0次
	dp11 := make([]int, n) // 状态数组dp11：第i天持有股票，卖出过1次

	// 2.起始状态：
	dp00[0] = 0          // 第0天不持有股票，且卖出过0次，说明第0天没有发生任何交易，利润为0，即：dp00[0]=0
	dp01[0] = 0          // 第0天不持有股票，且卖出过1次，说明第0天买了1次又立马卖了，利润为0，即：dp01[0]=0
	dp02[0] = 0          // 第0天不持有股票，且卖出过2次，说明第0天买卖了2次，利润为0，即：dp02[0]=0
	dp10[0] = -prices[0] // 第0天持有股票，且卖出过0次，说明第0天买入了股票，利润为负的买入股票花的钱，即dp10[0]=-prices[0]
	dp11[0] = -prices[0] // 第0天持有股票，且卖出过1次，说明第0天买卖了一次股票，并又买入了一次，利润为负的买入股票花的钱，即dp11[0]=-prices[0]

	// 3.状态转移：
	for i := 1; i < n; i++ {
		// 3.1 第i天不持有股票：
		// 3.1.1 卖出过0次：此时由于没有发生过股票买卖，因此利润一直是0，即dp00[i]=0
		dp00[i] = 0
		// 3.1.2 卖出过1次：
		// 可能是第i-1天持股且卖出过0次，是在第i天当天卖出的，此时第i天为止的利润=第i-1天为止的利润+第i天卖出股票赚的钱，即：dp01[i]=dp10[i-1]+prices[i]
		// 可能是第i-1天已经不持股且卖出过1次，第i天当天也没有买入，此时第i天为止的利润=第i-1天为止的利润，即：dp01[i]=dp01[i-1]
		// 第i天不持有股票且卖出过1次的最大利润，是上述两种情况的较大值
		dp01[i] = maxInt(dp10[i-1]+prices[i], dp01[i-1])
		// 3.1.3 卖出过2次：
		// 可能是第i-1天持股且卖出过1次，是在第i天当天卖出的，此时第i天为止的利润=第i-1天为止的利润+第i天卖出股票赚的钱，即：dp02[i]=dp11[i-1]+prices[i]
		// 可能是第i-1天已经不持股且卖出过2次，第i天当天也没有买入，此时第i天为止的利润=第i-1天为止的利润，即：dp02[i]=dp02[i-1]
		// 第i天不持有股票且卖出过2次的最大利润，是上述两种情况的较大值
		dp02[i] = maxInt(dp11[i-1]+prices[i], dp02[i-1])
		// 3.2 第i天持有股票：
		// 3.2.1 卖出过0次：
		// 可能是第i-1天未持有且卖出过0次，是在第i天当天买入的，此时第i天为止的利润=第i-1天为止的利润+第i天买入股票花的钱，即：dp10[i]=dp00[i-1]-prices[i]
		// 可能是第i-1天已经持有股票且卖出过0次，而第i天当天也没有卖出，此时第i天为止的利润=第i-1天为止的利润，即：dp10[i]=dp10[i-1]
		// 第i天持有股票且卖出过0次的最大利润，是上述两种情况的较大值
		dp10[i] = maxInt(dp00[i-1]-prices[i], dp10[i-1])
		// 3.2.2 卖出过1次：
		// 可能是第i-1天未持有且卖出过1次，是在第i天当天买入的，此时第i天为止的利润=第i-1天为止的利润+第i天买入股票花的钱，即：dp11[i]=dp01[i-1]-prices[i]
		// 可能是第i-1天已经持有股票且卖出过1次，而第i天当天也没有卖出，此时第i天为止的利润=第i-1天为止的利润，即：dp11[i]=dp11[i-1]
		// 第i天持有股票且卖出过1次的最大利润，是上述两种情况的较大值
		dp11[i] = maxInt(dp01[i-1]-prices[i], dp11[i-1])
	}

	// 4.因为要想利益最大，最后一天一定要将股票全部卖出，即最后一天一定不会持有股票，因此dp00[n-1],dp01[n-1],dp02[n-1]的较大值，就是整个周期中买卖多次股票所能得到的最大利润
	return maxInt(dp00[n-1], dp01[n-1], dp02[n-1])
}
