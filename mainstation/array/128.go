package array

import (
	"math"
)

func longestConsecutive(nums []int) int {
	// 并查集

	/*
		一个未排序数组，要找出数字连续最长序列，且时间复杂度为n，因此只能进行一次遍历且不能进行排序，考虑使用并查集
		首先使用map将数据去重，然后遍历每个数
			查：查一组连续序列的第一个数（即：判断该数前面还有没有数），如果当前数不是一组连续序列的第一个数，就跳过
			并：在找到一组连续序列的第一个数后，就寻找以该数开头的后续序列，将后续序列归并，直到找到这组序列的最后一个数，计算这组序列的长度
		找到每组序列的最长的那一个序列，就是我们要找的结果集
	*/

	// 1.特殊情况：当数组为空，直接返回0
	if len(nums) == 0 {
		return 0
	}

	// 2.首先使用map将数据去重，键：该
	hashMap := make(map[int]bool)
	for _, num := range nums {
		hashMap[num] = true
	}

	// 3.遍历每个数，执行并查操作
	res := math.MinInt
	for num, _ := range hashMap {
		// 3.1 查：查一组连续序列的第一个数（即：判断该数前面还有没有数）
		// 如果当前数不是一组连续序列的第一个数，就跳过
		// 如果当前数是一组连续序列的第一个数，就寻找以该数开头的后续序列
		if ok := hashMap[num-1]; !ok {
			flag := num        // 表示当前找到了这组连续序列中的哪个数，初始化为这组连续序列的第一个数num
			currentLength := 1 // 初始化以该num开头的连续序列长度为1
			// 3.2 并：在找到一组连续序列的第一个数后，就寻找以该数开头的后续序列，将后续序列归并，直到找到这组序列的最后一个数，计算这组序列的长度
			for {
				if ok := hashMap[flag+1]; ok {
					// 如果当前数的下一个数在数组中，就归并，flag+1更新当前找到连续序列中的哪个数，currentLength+1更新这组序列长度
					flag++
					currentLength++
				} else {
					// 如果当前数的下一个数不在数组中，说明该组连续序列已经找完了，此时跳出循环，寻找下一个连续序列
					break
				}
			}
			// 3.3 找到每组序列的最长的那一个序列，就是我们要找的结果集
			res = maxInt(res, currentLength)
		}
	}

	// 4.返回结果集
	return res
}
