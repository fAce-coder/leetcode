package array

import (
	"sort"
)

func majorityElement(nums []int) int {
	// 摩尔投票

	/*
		从数组的第一个数开始，依次向后找，这里想象为打仗
		如果某个数与自己相同，说明是友军，则加入自己的阵营，阵营数量加1
		如果遇到某个数和自己不同，说明是敌军，则极限一换一，阵营数量减1
		如果走到一半阵营空了(阵营数量为0)，说明到这里前面已经厮杀完毕；此时与第一个数一样另起炉灶，建立起自己的阵营与后方战斗
		由于众数大于n/2，所以极限一换一之后还会有该众数剩余，因此最后阵营里剩的肯定是那个众数，即我们想要的结果
	*/

	// 1.初始化阵营小兵为第一个元素，初始化阵营数量为1
	res := nums[0]
	count := 1

	// 2.遍历数组中的数，开始战斗
	for i := 1; i < len(nums); i++ {
		// 判断当前阵营中的小兵数是否为0，即是否已经厮杀完
		if count != 0 {
			// 2.1 如果当前阵营还有人，则判断遇到的这个人是敌是友
			if nums[i] != res {
				// 2.1.1 如果遇到某个数和自己不同，说明是敌军，则极限一换一，阵营数量减1
				count--
			} else {
				// 2.1.2 如果某个数与自己相同，说明是友军，则加入自己的阵营，阵营数量加1
				count++
			}
		} else {
			// 2.2 如果当前阵营没人了(阵营数量为0)，说明到这里前面已经厮杀完毕；此时与第一个数一样另起炉灶，建立起自己的阵营与后方战斗
			res = nums[i]
			count++
		}
	}
	// 3.由于众数大于n/2，所以极限一换一之后还会有该众数剩余，因此最后阵营里剩的肯定是那个众数，即我们想要的结果，将这个结果返回
	return res
}

func majorityElement2(nums []int) int {
	// 哈希表

	/*
		创建一个哈希表，在golang中即为map，键为数组中的数字，值为数组中每个数字出现的次数
		数字每出现一次，就将其出现次数加1
		最终遍历哈希表，找出出现次数大于n/2的元素
		时间复杂度n，空间复杂度n
	*/

	// 1.初始化结果
	var res int

	// 2.初始化创建哈希表，键为数组中的数字，值为数组中每个数字出现的次数
	hashMap := make(map[int]int)

	// 3.数字每出现一次，就将其出现次数加1
	for _, num := range nums {
		hashMap[num]++
	}

	// 4.最终遍历哈希表，找出出现次数大于n/2的元素
	for key, value := range hashMap {
		if value > len(nums)/2 {
			res = key
			break
		}
	}

	// 5.将结果返回
	return res
}

func majorityElement3(nums []int) int {
	// 排序

	/*
		因为要找出数量大于n/2的元素，即众数
		因此只要将数组排序，此时中位数一定就是那个大于n/2的众数
	*/

	// 1.将切片转换成可排序切片，并调用内置排序方法进行排序
	sort.Sort(sortableNums(nums))

	// 2.返回排序后的中位数，即众数
	return nums[len(nums)/2]
}
