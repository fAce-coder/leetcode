package array

func rob(nums []int) int {
	// 动态规划

	/*
		该题要求在不触动警报的情况下（不偷相邻的两个房间），求整个街道（数组）中能偷的最大值，即偷到最后一间房屋时的最大值
		因此考虑将偷到最后一间房屋的最大值这个大问题，拆分成偷到第i间房屋的最大值这一子问题，最终当i=房屋数-1时，就是我们要求的最后一间房屋的最大值，即整个街道中能偷的最大值
		1.子问题（状态）：
			状态数组dp，dp[i]表示偷到第i间房屋时的最大值
		2.起始状态：
			偷到第0间房子时，最大值只能是只偷这一间所能得到的值，因此dp[0]=nums[0]
			偷到第1间房子时，如果偷第1间就不能偷第0间，偷了第0间就不能偷第1间，因此最大值取第0间和第1间的较大值，因此dp[1]=max(nums[0],nums[1])
		3.状态转移：
			偷到第i间房子时，有两种选择：
			3.1 偷第i间，因此不能偷第i-1间，所以最大值就是偷到第i-2间的最大值加第i间的值，即dp[i-2]+nums[i]
			3.2 不偷第i间，因此可以偷第i-1间，所以最大值就是偷到第i-1间的最大值，即dp[i-1]
			因此取这两种选择的最大值，就是偷到第i间房屋的最大值
	*/

	// 1.特殊情况：
	n := len(nums)
	if n == 1 {
		// 当只有1间房子时，最大值只能是只偷这一间所能得到的值
		return nums[0]
	} else if n == 2 {
		// 当只有2间房子时，如果偷第1间就不能偷第0间，偷了第0间就不能偷第1间，因此最大值取第0间和第1间的较大值
		return maxInt(nums[0], nums[1])
	}

	// 2.状态数组dp，dp[i]表示偷到第i间房屋时的最大值
	dp := make([]int, n)

	// 3.起始状态
	// 偷到第0间房子时，最大值只能是只偷这一间所能得到的值，因此dp[0]=nums[0]
	dp[0] = nums[0]
	// 偷到第1间房子时，如果偷第1间就不能偷第0间，偷了第0间就不能偷第1间，因此最大值取第0间和第1间的较大值，因此dp[1]=max(nums[0],nums[1])
	dp[1] = maxInt(nums[0], nums[1])

	// 4.状态转移：偷到第i间房子时的最大值
	for i := 2; i < n; i++ {
		// 偷到第i间房子时，有两种选择：
		// 		偷第i间，因此不能偷第i-1间，所以最大值就是偷到第i-2间的最大值加第i间的值，即dp[i-2]+nums[i]
		// 		不偷第i间，因此可以偷第i-1间，所以最大值就是偷到第i-1间的最大值，即dp[i-1]
		// 因此取这两种选择的最大值，就是偷到第i间房屋的最大值
		dp[i] = maxInt(dp[i-2]+nums[i], dp[i-1])
	}

	// 5.最终当i=房屋数-1时，就是我们要求的最后一间房屋的最大值，即整个街道中能偷的最大值，返回结果
	res := dp[n-1]
	return res
}
