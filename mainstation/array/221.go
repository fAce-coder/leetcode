package array

func maximalSquare(matrix [][]byte) int {
	// 动态规划

	/*
		本题要求二维矩阵中只包含1的最大正方形，而这个最大正方形，肯定是以矩阵中某一个索引位置的数为右下角的
		因此将整个二维矩阵中包含的最大正方形这一大问题，拆分成求以矩阵中每个索引为右下角的最大正方形，最终所有索引处最大的值，就是要求的整个矩阵中的值
		因为最终要求正方形面积，正方形面积=边长*边长，因此我们先讨论以矩阵中每个索引为右下角的最大正方形边长，最终根据边长求出面积
		1.子问题（状态）：
			dp[i][j]表示以矩阵中某个索引处（i，j）为右下角的最大正方形边长
		2.起始状态：
			因为第一行的列宽是1，第一列的行高是1，因此以第一行和第一列中的索引为右下角的正方形边长的最大值只能是1
			2.1 当索引处的值为0时，说明以该索引为右下角组不成正方形，因此记dp[i][j]为0
			2.2 当索引处的值为1时，说明以该索引为右下角能组成边长为1的正方形，因此记dp[i][j]为1
		3.状态转移：
			3.1 当索引处的值为0时，说明以该索引为右下角组不成正方形，因此记dp[i][j]为0
			3.2 当索引处的值为1时：
				如果以索引（i，j）为右下角的最大正方形边长是n，则其上方、左方、左上方的最大正方形边长至少是n-1（可画图理解），即：
					min(dp[i][j−1],dp[i−1][j],dp[i−1][j−1]) >= dp[i][j]−1
				同理，如果分别以索引（i，j）的上方、左方、左上方为右下角的最大正方形边长三者最小值是n，则加上索引（i，j）后，以索引（i，j）为右下角的最大正方形边长至少是n+1，即：
					dp[i][j] >= min(dp[i][j−1],dp[i−1][j],dp[i−1][j−1])+1
				联立两个不等式，得到状态转移方程dp[i][j] = min(dp[i][j−1],dp[i−1][j],dp[i−1][j−1])+1
	*/

	// 1.初始化状态数组：dp[i][j]表示以矩阵中某个索引处（i，j）为右下角的最大正方形边长
	m := len(matrix)
	n := len(matrix[0])
	dp := make([][]int, m)
	for i := 0; i < m; i++ {
		dp[i] = make([]int, n)
	}

	// 2.遍历矩阵中的每一个索引，求以矩阵中每个索引为右下角的最大正方形边长
	res := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if matrix[i][j] == '0' {
				// 2.1 当索引处的值为0时，说明以该索引为右下角组不成正方形，因此记dp[i][j]为0
				dp[i][j] = 0
			} else {
				// 2.2 当索引处的值为1时
				if i == 0 || j == 0 {
					// 因为第一行的列宽是1，第一列的行高是1，因此以第一行和第一列中的索引为右下角的正方形边长的最大值只能是1
					dp[i][j] = 1
				} else {
					// 其他索引处状态转移方程dp[i][j] = min(dp[i][j−1],dp[i−1][j],dp[i−1][j−1])+1（详解见题解）
					dp[i][j] = minInt(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
				}
				// 2.3 最终所有索引处最大的值，就是要求的整个矩阵中的值
				res = maxInt(res, dp[i][j])
			}
		}
	}

	// 3.返回最终要求正方形面积，正方形面积=边长*边长
	return res * res
}
