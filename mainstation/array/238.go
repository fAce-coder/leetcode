package array

func productExceptSelf1(nums []int) []int {
	// 辅助数组，时间n空间n

	/*
		该题要求在数组中索引i处，填充除该索引处数字外的数组中其他数字的乘积，且要求时间复杂度n
		除某索引处数字外的数组中其他数字的乘积 = 该数字左边数字的乘积 * 该数字右边数字的乘积
		因此维护两个辅助数组，一个数组在索引i处存原数组中索引i处数字左侧数字的乘积，一个数组在索引i处存原数组中索引i处数字右侧数字的乘积
		最终两个辅助数组中索引i处数字相乘，就是结果集所要求的除某索引处数字外的数组中其他数字的乘积
	*/

	// 1.初始化两个辅助数组和结果集
	n := len(nums)
	left := make([]int, n)  // left数组在索引i处存原数组中索引i处数字左侧数字的乘积
	right := make([]int, n) // right数组在索引i处存原数组中索引i处数字右侧数字的乘积
	res := make([]int, n)   // res数组储存结果集

	// 2.求某个数字左侧所有数字的乘积
	left[0] = 1 // 第一个数左侧数字的乘积默认为1
	for i := 1; i < n; i++ {
		// 索引i处数字左侧所有数字的乘积 = 索引i-1左侧所有数字的乘积 * 索引i-1处的数字
		left[i] = left[i-1] * nums[i-1]
	}

	// 3.求某个数字右侧所有数字的乘积
	right[n-1] = 1 // 最后一个数右侧数字的乘积默认为1
	for i := n - 2; i >= 0; i-- {
		// 索引i处数字右侧所有数字的乘积 = 索引i+1右侧所有数字的乘积 * 索引i+1处的数字
		right[i] = right[i+1] * nums[i+1]
	}

	// 4.最终两个辅助数组中索引i处数字相乘，就是结果集所要求的除某索引处数字外的数组中其他数字的乘积
	for i := 0; i < n; i++ {
		// 除某索引处数字外的数组中其他数字的乘积 = 该数字左边数字的乘积 * 该数字右边数字的乘积
		res[i] = left[i] * right[i]
	}

	// 5.返回结果集
	return res
}

func productExceptSelf2(nums []int) []int {
	// 辅助数组 时间n空间1

	/*
		进阶要求空间复杂度为1，即不使用额外空间，但要返回的结果集数组不属于额外空间
		因此考虑将分别存储左右乘积的两个辅助数组，合并到结果集数组这一个数组中
		先把结果集用作存储某个数左侧乘积的辅助数组，然后用一个变量来记录某个数的右侧乘积，依次与左侧乘积数组中的数相乘，这样也可以得到结果集，且空间复杂度降为1
		即：将空间复杂度为n的解法中，记录某个数右侧乘积的数组，压缩为一个记录变量
	*/

	// 1.初始化结果集
	n := len(nums)
	res := make([]int, n)

	// 2.先将结果集作为储存某个数左侧乘积的辅助数组
	res[0] = 1 // 第一个数左侧数字的乘积默认为1
	for i := 1; i < n; i++ {
		// 索引i处数字左侧所有数字的乘积 = 索引i-1左侧所有数字的乘积 * 索引i-1处的数字
		res[i] = res[i-1] * nums[i-1]
	}

	// 3.使用right变量作为记录某个数的右侧乘积的变量，替代空间为n的数组
	right := 1 // 最后一个数右侧数字的乘积默认为1
	for i := n - 1; i >= 0; i-- {
		// 除某索引处数字外的数组中其他数字的乘积 = 该数字左边数字的乘积 * 该数字右边数字的乘积
		res[i] = right * res[i]
		// 更新索引i处右侧的乘积为索引i-1处右侧的乘积，即索引i处右侧的乘积 * 索引i处的数字
		right = right * nums[i]
	}

	// 4.返回结果集
	return res
}
