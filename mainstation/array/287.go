package array

func findDuplicate1(nums []int) int {
	// 二分查找

	/*
		长度n+1的数组，数字范围在[1,n]范围内，根据抽屉原理（10个苹果放在9个抽屉里，一定会有至少2个苹果被放进同一个抽屉），因此肯定会有一个数字重复，而题目也保证了只有一个数字重复（即只有一个抽屉里有2个苹果，其他抽屉里都是1个苹果）
		如果[1,n]中某个数重复了，则会导致数组中小于等于该重复数字的个数大于该数字本身（后文简称为异常现象），并且这一异常现象会导致连锁反应，使比该重复数字大的所有数字都产生这种异常现象
			例：[1,3,4,2,2]中，重复数字是2，因此数组中小于等于2的个数是3（1，2，2），并且导致比重复数字2大的数字（3，4）都会产生这种异常现象，即：数组中小于等于3的个数是4（1，2，2，3），数组中小于等于4的个数是5（1，2，2，3，4）
		因此我们想要找到该重复数字，只需在[1,n]中找到最先（即最小）的引起异常现象的那个数字，该数字就是要找的重复数字
		首先我们可以想到暴力解法，可以直接在数字[1,n]中，从最小的数字1开始，看是否是当前数字导致数组中出现了异常现象，但如果重复的数字是最后一个数字n，那这样遍历一遍的时间复杂度是n，并不是最优解；而数字[1,n]又是有序的，因此我们可以使用最适合有序数组的方法二分法来找最先导致该异常现象的数字，即重复数字
		二分法取得[1,n]的中间数mid，遍历一遍nums数组，看该数是否处于异常现象：
			如果该数处于异常现象，则说明要么该数就是引起异常现象的数；要么该数只是被影响的数，引起异常现象的数比它还小；因此，我们将右指针right移动到mid处，继续向左寻找（之所以不像其他二分法那样是mid-1，是因为该数可能就是那个引起异常现象的数）
			如果该数未处于异常现象，则说明引起异常现象的数一定比它大，因此，我们将左指针left移动到mid+1处，继续向右寻找
		越界条件：
			因为右指针只是移动到了mid而不是mid-1，因此不能像其他二分法那样在左右指针重合的情况下还继续寻找，因为继续寻找会导致永远跳不出循环，因此越界条件由left<=right变为left<right
			当左指针先到达那个重复的数字，则在后续的循环中左指针不动，右指针靠向左指针；当右指针先到达那个重复的数字，则在后续的循环中右指针不动，左指针靠向右指针；当左右指针重合时，重合位置的数就是我们要找的那个最先引起异常现象的重复的数
	*/

	// 1.初始化左右指针分别为数字[1,n]的左右边界1和n
	left := 1
	right := len(nums) - 1
	// 2.二分查找，寻找最先导致异常现象的数字
	for left < right {
		// 2.1 取得中间数mid
		mid := (left + right) / 2
		// 2.2 遍历一遍nums数组，统计数组中小于等于中间数mid的数字个数
		count := 0
		for _, num := range nums {
			if num <= mid {
				count++
			}
		}
		if count > mid {
			// 2.3 如果该数处于异常现象，则说明要么该数就是引起异常现象的数；要么该数只是被影响的数，引起异常现象的数比它还小；因此，我们将右指针right移动到mid处，继续向左寻找
			right = mid
		} else {
			// 2.4 如果该数未处于异常现象，则说明引起异常现象的数一定比它大，因此，我们将左指针left移动到mid+1处，继续向右寻找
			left = mid + 1
		}
	}
	// 3.当左右指针重合时，重合位置的数就是我们要找的那个最先引起异常现象的重复的数
	return left
}

func findDuplicate2(nums []int) int {
	// 快慢双指针：龟兔赛跑

	/*
		数组长度为n+1，而数组中数字的范围是[1,n]，而题目又保证只有1个重复的数字，因此数组中除了这个重复数字与[1,n]中的某个数字的个数是2:1的关系之外，数组中其他的数字都与[1,n]中的某个数字一一对应
			如：1，3，4，2，2；除了2这个重复数字与[1，2，3，4]中数字个数是2:1，其他的都是1:1
		因此考虑将数组中数字的索引与数字本身形成一个链表，即i->nums[i]->nums[nums[i]]->...
		数组长度为n+1，即数组中数字索引为[0,n]，因此索引比数字范围多一位，而多的这一位就是那个重复数字，这样该重复数字是有2个索引指向它，而该重复数字作为索引时却指向同1个数字，因此链表一定有环，且是因为这个重复数字才导致的环，因此环的入口就是重复数字
			如：1，3，4，2，2；形成链表为0->1->3->2->4->2->4->2->...无穷循环，重复数字2有索引3和索引4指向它，而重复数字2作为索引时却只指向4，因此在2和4之间不断转圈，而这个环的入口就是重复数字2
		因此设置快慢指针（龟兔赛跑）来寻找这个环的入口：
			从0索引开始，慢指针一次走1步，快指针一次走2步，直到二者相遇（因为有环，所以二者一定会在某个时刻相遇在环中的某一点上）
			设无环的部分长度是a，有环的部分长度是b，相遇时慢指针走的长度是slow，快指针走的长度是fast
			快慢指针相遇在环中的某一点上，相遇时：
				fast速度是slow的2倍，因此fast走的距离是slow的2倍：fast = 2 * slow
				fast和slow指针都先走过a步，然后在环内绕圈，直到重合，又因为fast比slow快，因此fast是在套了slow整数倍圈数n之后才与slow相遇：fast = slow + nb
				联立上面两个方程得出：slow=nb，fast=2nb
			接下来寻找环的入口，即那个重复数字：
				因为无环长度是a，因此从开头走a步就是环的入口，但我们不知道a的长度是多少，但可以通过slow来推断
				因为slow走了nb步，而如果再走a步，即a+nb，就会到达环的入口位置（因为相当于先走a步走到环的入口，再绕环整数圈，绕完还是在环的入口）
				因此将一个指针res放置在开头，跟slow一起走，当res指针走了a步，slow指针走了a+nb步时，二者相遇在环的入口，即重复数字位置
	*/

	// 1.初始化快慢指针都是索引0
	slow := 0
	fast := 0

	// 2.快慢指针移动，直到二者相遇在环中的某一点上
	for {
		slow = nums[slow]       // 慢指针一次走1步
		fast = nums[nums[fast]] // 快指针一次走2步
		if slow == fast {
			// 二者相遇，跳出循环
			break
		}
	}

	// 3.寻找环的入口，即要求的重复数字
	res := 0 // 将res指针放置在开头
	for {
		// res指针和slow指针一起走
		res = nums[res]
		slow = nums[slow]
		if res == slow {
			// 二者相遇位置就是环的入口，跳出循环
			break
		}
	}

	// 4.返回结果
	return res
}
