package array

func lengthOfLIS(nums []int) int {
	// 动态规划

	/*
		该题要求整个数组中最长递增子序列的长度，而这个最长子序列肯定是以数组中的某个数结尾的（结尾表示这个数一定在递增子序列中且是递增子序列中最后一位）
		因此考虑将求整个数组中最长递增子序列的长度这一大问题，拆分为求以数组中每个数为结尾的最长递增子序列的问题，因此使用动态规划
		1.子问题（状态）：
			dp[i]表示以数组中nums[i]为结尾的最长递增子序列的长度
		2.起始状态：
			数组中第一个数为结尾的递增子序列只有其自己，因此dp[0]只能是1
			因为数组中每个元素自身都可以单独成为一个子序列，即以nums[i]为结尾的最长递增子序列的长度最小是1（即只有nums[i]自身），因此每个索引处的最长递增子序列长度都初始化为1
		3.状态转移：
			因为dp[i]保存的是以nums[i]为结尾的最大递增子序列长度，因此要求dp[i]，就要参考以索引i之前的索引为结尾的最大递增子序列长度，通过他们来推断当前索引i为结尾的最大递增子序列长度
			因此遍历索引i之前的数组中的数nums[j]（0<=j<i）：
				首先要满足严格递增：因此如果nums[j]<nums[i]，则说明满足严格递增条件，即nums[j]和nums[i]能形成递增序列，一旦组成递增序列，则以nums[j]为结尾的序列也会自然而然的接到nums[i]上，因此dp[i]=dp[j]+1；如果nums[j]>=nums[i]，则nums[j]和nums[i]不能形成递增序列，跳过
				其次要满足最大：因为nums[i]可以和若干个nums[j]组成递增序列，但我们要求出最大递增子序列，因此要看以哪个nums[j]为结尾的最大递增子序列连在nums[i]上能使得以nums[i]为结尾的递增子序列最大，因此就要找dp[j]最大的那个
		正如前面所说，整个数组中最长子序列肯定是以数组中某个数字结尾的，因此状态数组中最大的值，就是整个数组中最长递增子序列的长度
	*/

	// 1.状态数组：dp[i]表示以数组中nums[i]为结尾的最长递增子序列的长度
	n := len(nums)
	dp := make([]int, n)

	// 2.起始状态：
	// 		数组中第一个数为结尾的递增子序列只有其自己，因此dp[0]只能是1
	// 		因为数组中每个元素自身都可以单独成为一个子序列，即以nums[i]为结尾的最长递增子序列的长度最小是1（即只有nums[i]自身），因此每个索引处的最长递增子序列长度都初始化为1
	for i := 0; i < n; i++ {
		dp[i] = 1
	}

	// 3.状态转移：
	for i := 1; i < n; i++ {
		// 因为dp[i]保存的是以nums[i]为结尾的最大递增子序列长度，因此要求dp[i]，就要参考以索引i之前的索引为结尾的最大递增子序列长度，通过他们来推断当前索引i为结尾的最大递增子序列长度
		for j := 0; j < i; j++ {
			// 如果nums[j]<nums[i]，则说明满足严格递增条件
			if nums[j] < nums[i] {
				// 看以哪个nums[j]为结尾的最大递增子序列连在nums[i]上能使得以nums[i]为结尾的递增子序列最大，因此就要找dp[j]最大的那个
				dp[i] = maxInt(dp[i], dp[j]+1)
			}
		}
	}

	// 4.状态数组中最大的值，就是整个数组中最长递增子序列的长度
	return maxInt(dp...)
}
