package array

func findDisappearedNumbers(nums []int) []int {
	// 原地置换

	/*
	   可以使用map作为哈希表，将数组去重后，暴力遍历1-n挨个判断是否在哈希表中存在，但这种做法时间复杂度和空间复杂度都太高，且题目要求时间复杂度为n且不使用额外空间(空间复杂度为1)，因此考虑原地置换
	   1.标准的[1,n]范围内的数组，从小到大排序后其索引和数据都是一一对应的关系，如nums[0]对应1，nums[n-1]对应n
	   2.在要判断的参数数组中，因为可能有重复的元素，导致有些元素没有，所以从小到大排序后有些数无法和索引一一对应
	   		2.1重复的数：1个索引对应多个数
	   		2.2缺失的数：1个索引对应0个数
	   3.因此要找到缺失的数，通过找到对应0个数的索引就可以推断出缺失的数
	   4.考虑从头开始遍历数组，将当前的数字-1对应的索引下的数字变成负数(如果这个数字是正数才变负数，因为如果是负数说明这个索引之前已经出现过一次，即重复的数，不用重复标记)，即相当于给该索引打了个标记，说明该索引出现过，即该数出现过，不是缺失的数字
	   5.最终，数组中是正数(正数说明该索引没被打过标记，即该索引没有对应的数字)的数字对应的索引+1，就是没有出现过的那个数字
	*/

	// 1.初始化结果
	res := make([]int, 0)

	// 2.从头开始遍历数组，对出现过的数字对应的索引进行标记
	for _, num := range nums {
		// 将当前的数字-1对应的索引下的数字变成负数，即相当于给该索引打了个标记，说明该索引出现过，即该数出现过，不是缺失的数字
		index := absInt(num) - 1
		// 如果这个数字是正数才变负数，因为如果是负数说明这个索引之前已经出现过一次，即重复的数，不用重复标记
		if nums[index] > 0 {
			nums[index] = -nums[index]
		}
	}

	// 3.再次遍历数组，数组中是正数(正数说明该索引没被打过标记，即该索引没有对应的数字)的数字对应的索引+1，就是没有出现过的那个数字
	for i, num := range nums {
		if num > 0 {
			res = append(res, i+1)
		}
	}

	// 4.将结果返回
	return res

}
