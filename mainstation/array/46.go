package array

func permute(nums []int) [][]int {
	// 递归+回溯

	/*
		这类递归回溯的问题，首先画出一个树状图，以空结果集为根节点，创建分支时根节点将候选数组中的每一个数（树的边）加入到结果集中，来得到一个子节点（更靠近真正结果集的临时结果集）
		再以子节点为根节点依次类推，通过标记的方式标记已经加入到结果集中的数字（模拟删除），尝试将原数组所有数字都标记（表示最后一个数已经加入）
		最终，每一个分支的叶子节点就是其中一个结果集
	*/

	// 1.初始化
	n := len(nums)
	// 1.1 初始化结果集
	res := make([][]int, 0)
	// 1.2 初始化标志位数组
	used := make([]bool, n)
	// 1.3 初始化单个结果集
	path := make([]int, 0)

	// 2.递归函数，从树的根节点开始，逐层向下去叶子节点中寻找单个结果集，并加入到最终结果集中
	var dfs func(int, []int, []bool)
	// depth：树的层数，逐层向下找
	// path：单个结果集，记录树中一条路径中从根节点到叶子节点的变化过程，最终到达叶子节点时，path就是最终结果集中的一个
	// used：标志位数组，用来标记到树中的某个分支的某一层时，已经走过的边，即：已经用过了哪些原数组中的值（模拟删除已经用过的值）
	dfs = func(depth int, path []int, used []bool) {
		// 2.1 如果找到了树的最后一层叶子节点，此时path就是最终结果集中的一个，将其加入最终结果集
		if depth == n {
			newPath := make([]int, 0)
			newPath = append(newPath, path...)
			res = append(res, newPath)
		}
		// 2.2 创建分支：根节点将候选数组中的每一个数（树的边）加入到结果集中，来得到一个子节点（更靠近真正结果集的临时结果集）
		for i := 0; i < n; i++ {
			// 只有当原始数组中的数没被使用过，才可以加入到临时结果集path中
			if !used[i] {
				// 2.2.1 将该值加入到临时结果集path中，相当于给根节点增加了一条向下延伸的边，来得到一个子节点
				path = append(path, nums[i])
				used[i] = true // 标记该数已经被使用
				// 2.2.2 从此子节点递归地向下延伸
				dfs(depth+1, path, used)
				// 2.2.3 这条路径延伸到叶子节点，就回溯，从而继续延伸从根节点发出的其他路径
				path = path[:len(path)-1]
				used[i] = false
			}
		}
	}

	// 3.从根节点开始查找结果集
	dfs(0, path, used)

	// 4.返回最终结果集
	return res
}
