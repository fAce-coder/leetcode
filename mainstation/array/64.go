package array

func minPathSum(grid [][]int) int {
	// 动态规划

	/*
		该题要求从整个数组的左上角到右下角的最小路径和，考虑将整个数组（到右下角）这一大问题，拆分成到数组中某个位置的最小路径和这一子问题
		最终以右下角为终点的子问题结果，就是要求的最终问题结果，因此考虑动态规划
		1.子问题（状态）：dp[i][j]是数组中以[i,j]下标为结尾的最小路径和
		2.起始状态：dp[0][0]，数组的左上角为结尾的最小路径和，就是数组中以[0,0]下标的数据自身
		3.状态转移：
			因为移动路径只能向下或向右，因此某个索引位置的子问题结果就是其上面的子问题结果和左面子问题结果中较小的值，再加上当前索引的数组中的值
			即：dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
	*/

	// 1.初始化一个与原数组大小相同的状态数组dp
	// 子问题（状态）：dp[i][j]是数组中以[i,j]下标为结尾的最小路径和
	m := len(grid)
	n := len(grid[0])
	dp := make([][]int, m)
	for i := 0; i < m; i++ {
		dp[i] = make([]int, n)
	}

	// 2.状态转移
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if i == 0 && j == 0 {
				// 起始状态：dp[0][0]，数组的左上角为结尾的最小路径和，就是数组中以[0,0]下标的数据自身
				dp[i][j] = grid[i][j]
			} else if i == 0 && j != 0 {
				// 如果是第一行，则路径只可能来自其左侧
				dp[i][j] = dp[i][j-1] + grid[i][j]
			} else if i != 0 && j == 0 {
				// 如果是第一列，则路径只可能来自其右侧
				dp[i][j] = dp[i-1][j] + grid[i][j]
			} else {
				// 除了第一行和第一列，其他索引位置的子问题结果就是其上面的子问题结果和左面子问题结果中较小的值，再加上当前索引的数组中的值
				dp[i][j] = minInt(dp[i][j-1], dp[i-1][j]) + grid[i][j]
			}
		}
	}

	// 3.最终以右下角为终点的子问题结果，就是要求的最终问题结果
	return dp[m-1][n-1]
}
