package array

func sortColors(nums []int) {
	// 三指针

	/*
		题目要求不使用sort排序、一趟扫描（时间复杂度n）、常数空间（空间复杂度1，原数组内交换）
		因为最终要把0都挪到左侧，2最终都要挪到右侧，因此考虑头尾双指针，头指针用来接收0（[0,l-1]都是0），尾指针用来接收2（[r+1,n-1]都是2）
		指针p从头开始寻找，找到0与头指针交换，找到2与尾指针交换，找到1则跳过
		由于[0,p-1]是已经处理过的数值，0和2已经分到了两端，1也已经跳过，因此[l,p-1]都是1，[p,r]则是未处理的数据
		如果nums[p]=0，将l与p索引的值进行互换，即将l处的1和p处的0进行交换，此时p索引下新值是1，直接跳过；因此头指针和p都后移一位
		如果nums[p]=1，则p后移直接跳过
		如果nums[p]=2，将p与r索引的值进行互换，但p和r都是未处理的数，因此不确定p索引下新值是否是1，因此不能直接跳过；因此只有右指针左移一位，p不动
	*/

	// 1.初始化头尾指针、寻找指针
	left := 0
	right := len(nums) - 1
	p := 0

	// 2.在寻找指针没越过右指针时
	// 本来应该是越过数组中最后一个数才算终止，但右指针右侧已经全是2了，此时没有寻找必要，因此以越过右指针为终止条件，减少查找次数
	for p <= right {
		// 判断p所在索引的数字
		if nums[p] == 0 { // 2.1 找到0就与头指针交换
			nums[left], nums[p] = nums[p], nums[left]
			p++
			left++
		} else if nums[p] == 2 { // 2.2 找到2就与尾指针交换
			nums[right], nums[p] = nums[p], nums[right]
			right--
		} else { // 2.3 找到1就跳过
			p++
		}
	}
}
