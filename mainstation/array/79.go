package array

func exist(board [][]byte, word string) bool {
	// 递归+回溯

	/*
		这类递归+回溯的问题，首先画出一个树状图
		树的根节点是以网格board中的某一个字母为起点，分别以其上下左右的字母作为当前节点的一个分支（树的边），形成一个当前节点和其某个分支的边组成的更加靠近结果集的字母组合（树的节点）
		因为同一个单元格内的字母不允许被重复使用，因此考虑在递归时将当前单元格内字母设置为空，在回溯时再恢复，来避免重复选取
	*/

	// 1.m*n的二维字符网格
	m := len(board)
	n := len(board[0])

	// 2.定义递归函数
	var dfs func(int, int, int) bool
	// i：寻找单词起点（树的根节点）的行索引
	// j：寻找单词起点（树的根节点）的列索引
	// k：当前找到了目标单词中的第几个字母的索引（表示距离目标的接近程度）
	dfs = func(i int, j int, k int) bool {
		// 2.1 如果索引越界，或者当前（i，j）索引的字母不是目标字母，此时说明在树中该分支寻找失败，返回false
		if (i < 0 || i >= m) || (j < 0 || j >= n) || board[i][j] != word[k] {
			return false
		}
		// 2.2 如果当前（i，j）索引的字母是目标字母，且已经找到目标单词的最后一位，说明找到了目标单词（当前的树中节点就是目标单词），返回true
		if k == len(word)-1 {
			return true
		}
		// 2.3 如果当前（i，j）索引的字母是目标字母，但还没有找到目标单词的最后一位，则继续将树向下分支寻找
		// 2.3.1 因为同一个单元格内的字母不允许被重复使用，因此考虑在递归时将当前单元格内字母设置为空，来避免重复选取
		temp := board[i][j]
		board[i][j] = ' '
		// 2.3.2 在board中递归的向当前字母的上下左右找（以当前字母为根节点，其上下左右的字母为分支的边来创建分支，得到一个更靠近结果集的字母组合子节点），只有有一条路能走通就行（因此用||）
		res := dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1)
		// 2.3.3 在回溯时再恢复递归前置空的字母
		board[i][j] = temp
		// 2.3.4 返回结果
		return res
	}

	// 3.逐个尝试以board的每个字母作为起点（作为树的根节点）进行查找，如果找到就提前返回true
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if dfs(i, j, 0) {
				return true
			}
		}
	}
	// 如果跳出循环了还没返回true（即以board中每个字母为起点都找不到目标单词），此时说明目标单词不在board中，返回false
	return false
}
