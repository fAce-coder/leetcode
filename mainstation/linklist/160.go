package linklist

func getIntersectionNode(headA, headB *ListNode) *ListNode {
	// 双指针

	/*
		设链表A不相交的部分节点个数为a，链表B不相交的部分节点个数为b，链表A和B相交的部分节点个数为c（若不相交则c=0）
		思路：
			指针pa放到链表A的头节点，指针pb放到链表B的头节点，两个指针每次同时往前移动1步
			指针pa走到链表A的结尾时，从链表B的开头开始走；指针pb走到链表B的结尾时，从链表A的开头开始走
			如果指针pa和pb相遇的节点不是nil，则是两个链表相交的起始节点；如果指针pa和pb相遇的节点是nil，则两个链表不相交
		分析：
			若两个链表相交：若想找到相交的节点，只需要让两个指针在相交前，走过相同的步数
				若a==b：
					pa和pb同时从各自链表头节点开始走，走到各自链表结尾时，pa走过a，pb走过b，在相交前走过的距离相等，直接相交得出交点
				若a!=b：
					指针pa从A的头节点开始走，走到链表A的结尾时，走了a+c步；指针pb从B的头节点开始走，走到链表B的结尾时，走了b+c步
					此时若pa继续从链表B的头结点开始走，pb继续从链表A的头结点开始走，则在pa走过a+c+b、pb走过b+c+a时，即pa和pb都走过a+b+c的距离
					相当于在相交前走过的距离相等，都为a+b，此时相交得出交点
			若两个链表不相交：若想判断链表没有交点，只需要让两个链表走过相同的步数，同时到达nil节点
				若a==b：
					pa和pb同时从各自链表头节点开始走，走到各自链表结尾时，pa走过a，pb走过b，同时到达nil节点
				若a!=b：
					指针pa从A的头节点开始走，走到链表A的结尾时，走了a步；指针pb从B的头节点开始走，走到链表B的结尾时，走了b步
					此时若pa继续从链表B的头结点开始走，pb继续从链表A的头结点开始走，则在pa走过a+b、pb走过b+a时，即pa和pb都走过a+b的距离，同时到达nil节点
	*/

	// 1.初始化双指针：指针pa放到链表A的头节点，指针pb放到链表B的头节点，两个指针每次同时往前移动1步
	pa := headA
	pb := headB

	// 2.双指针开始移动，当双指针相遇时跳出循环
	for pa != pb {
		if pa != nil {
			pa = pa.Next // 指针pa没走到链表A的结尾时，向后移动1步
		} else {
			pa = headB // 指针pa走到链表A的结尾时，从链表B的开头开始走
		}

		if pb != nil {
			pb = pb.Next // 指针pb没走到链表B的结尾时，向后移动1步
		} else {
			pb = headA // 指针pb走到链表B的结尾时，从链表A的开头开始走
		}
	}

	// 3.返回双指针相遇位置
	// 双指针相遇的2种情况：
	// 		两个链表相交，双指针在交点处相遇，返回交点位置
	// 		两个链表不相交，双指针在nil处相遇，返回nil
	return pa
}
